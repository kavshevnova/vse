// Задача 2 – «processed» и потерянные сообщения
// Как отработает код?
//
// ОТВЕТ: Выведет "processed: cmd.1", но "processed: cmd.2" — НЕ ГАРАНТИРОВАНО.
// Возможно: программа завершится сразу после отправки cmd.2 (горутина ещё не обработала).
//
// Объяснение:
// - ch — небуферизованный канал
// - Горутина читает из ch в бесконечном цикле
// - run() отправляет cmd.1 (блокирует пока горутина не прочитает) → "processed: cmd.1" выведется
// - run() отправляет cmd.2 (блокирует пока горутина не прочитает) → горутина читает
// - Функция run() ЗАВЕРШАЕТСЯ после отправки cmd.2
// - main() тоже завершается немедленно
// - Горутина может успеть вывести "processed: cmd.2" ИЛИ НЕТ — зависит от планировщика
// - RACE CONDITION: нет синхронизации между run() и горутиной
//
// ИСПРАВЛЕНИЕ: добавить WaitGroup или close(ch) + ждать завершения горутины.
package main

import (
	"fmt"
)

func run() {
	ch := make(chan string)
	go func() {
		for m := range ch {
			fmt.Println("processed:", m)
		}
	}()

	ch <- "cmd.1"
	ch <- "cmd.2"
}

func main() { run() }
