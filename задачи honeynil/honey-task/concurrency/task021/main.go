// Задача 1 – Буферизированный канал и select
// Как отработает код?
//
// ОТВЕТ: DEADLOCK / программа зависнет навсегда.
//
// Объяснение:
// - Запускаются 5 горутин, каждая пишет в буферизированный канал c (cap=3)
// - 3 горутины успешно пишут (буфер вмещает 3), остальные 2 блокируются
// - Основной цикл for { select { case v := <-c: } } — бесконечный, никогда не завершается
// - wg.Wait() и close(c) НЕДОСТИЖИМЫ (код после бесконечного for никогда не выполнится)
// - После прочтения 5 сообщений из канала select будет читать нули из пустого канала — БЛОКИРОВКА!
// - Так как больше никто не пишет в c, select блокируется навсегда → DEADLOCK
//
// ИСПРАВЛЕНИЕ: нужно ограничить количество итераций for или использовать done-канал.
package main

import (
	"fmt"
	"strconv"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	c := make(chan string, 3)

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			c <- "Goroutine " + strconv.Itoa(i)
		}(i)
	}

	for {
		select {
		case v := <-c:
			fmt.Println(v)
		}
	}

	wg.Wait()
	close(c)
}
