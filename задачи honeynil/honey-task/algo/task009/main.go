package main

// Задача: минимизировать суммарную стоимость предметов с использованием K купонов.
// Каждый купон уменьшает цену предмета на X (минимум 0).
// Все K купонов можно применить к одному предмету: цена = max(a - K*X, 0).
// Оптимальная стратегия: применить все купоны к самому дорогому предмету.
//
// A = [8, 3, 10, 5, 13], K = 4, X = 7 → result = 12
// Самый дорогой: 13 → 13 - 4*7 = 13 - 28 = -15 → max(0) = 0
// Сумма без купона: 8+3+10+5+13 = 39
// С купоном на 13: 39 - 13 = 26, но max(13-28, 0)=0, поэтому 39 - 13 + 0 = 26? Нет.
// Правильно: купоны ПЕРЕРАСПРЕДЕЛЯЮТСЯ оптимально между предметами.
// Ждем: 39 - (результат применения K купонов оптимально) = ?
// Применяем все 4 купона к 13: 13 - 4*7 = max(-15, 0) = 0 → экономия 13
// Итого: 0 + 3 + 8 + 5 + 10 = 26. Но ожидаемый ответ 12?
//
// Пересчёт: может купоны применяются ПО ОДНОМУ к разным предметам?
// K=4 купона, X=7, применяем к самым дорогим:
// 13-7=6, 10-7=3, 8-7=1, 6-7=0 (или 5-7=0)
// Самые дорогие после сортировки: [13,10,8,5,3]
// Применяем по одному: 13→6, 10→3, 8→1 (3 купона), 4й к следующему 6→ нет, 6 самый большой
// Жадно: всегда применяем к максимуму
// [13,10,8,5,3]: к 13 → [6,10,8,5,3]; к 10 → [6,3,8,5,3]; к 8 → [6,3,1,5,3]; к 6 → [0,3,1,5,3]
// сумма = 0+3+1+5+3 = 12 ✓

import (
	"fmt"
	"sort"
)

// minCost возвращает минимальную сумму после применения k купонов со скидкой x каждый.
// Каждый купон применяется к одному предмету (снижает цену на x, минимум 0).
func minCost(prices []int, k, x int) int {
	// Жадный алгоритм: всегда применяем купон к самому дорогому предмету
	// Используем копию, чтобы не изменять оригинал
	p := make([]int, len(prices))
	copy(p, prices)

	for i := 0; i < k; i++ {
		// Сортируем по убыванию и применяем купон к первому
		sort.Sort(sort.Reverse(sort.IntSlice(p)))
		if p[0] >= x {
			p[0] -= x
		} else {
			p[0] = 0
		}
	}

	total := 0
	for _, v := range p {
		total += v
	}
	return total
}

func main() {
	prices := []int{8, 3, 10, 5, 13}
	fmt.Println(minCost(prices, 4, 7)) // 12
}
